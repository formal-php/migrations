{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>This library is a simple one way migration system.</p> <p>You can run both SQL and Commands migrations. You can choose to store which migrations have been run either in a database or on the filesystem.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>composer require formal/migrations\n</code></pre>"},{"location":"#basic-usage","title":"Basic usage","text":"<pre><code>use Formal\\Migrations\\Factory;\nuse Innmind\\OperatingSystem\\Factory as OS;\nuse Innmind\\Url\\{\n    Url,\n    Path,\n};\n\n$os = OS::build();\n\nFactory::of($os)\n    -&gt;storeVersionsOnFilesystem(Path::of('/some/folder/'))\n    -&gt;sql()\n    -&gt;files(Path::of('/path/to/sql/migrations/'))\n    -&gt;migrate(Url::of('mysql://user:pwd@127.0.0.1:3306/database'))\n    -&gt;match(\n        static fn() =&gt; print('Everything has been migrated'),\n        static fn(\\Throwable $error) =&gt; print($error-&gt;getMessage()),\n    );\n</code></pre>"},{"location":"commands/","title":"Commands","text":"<p>This kind of migration is useful to run some commands automatically after deploying a new version of your app.</p> <p>For example you have an Elasticsearch index and the new feature being deployed requires to rebuild the index just this one time. You can write a migration for this!</p>"},{"location":"commands/#getting-started","title":"Getting started","text":"migrate.php<pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nuse Formal\\Migrations\\{\n    Factory,\n    Commands\\Migration,\n};\nuse Innmind\\OperatingSystem\\Factory as OS;\nuse Innmind\\Server\\Control\\Server\\{\n    Command,\n    Process\\TimedOut,\n    Process\\Failed,\n    Process\\Signaled,\n};\nuse Innmind\\Url\\Url;\nuse Innmind\\Immutable\\Sequence;\n\nrequire 'path/to/composer/autoload.php';\n\nFactory::of(OS::build())\n    -&gt;storeVersionsInDatabase(\n        Url::of('mysql://user:pwd@127.0.0.1:3306/database'),\n    )\n    -&gt;commands()\n    -&gt;of(Sequence::of(\n        Migration::of(\n            '2024-10-04 Rebuild Elasticsearch',\n            Command::foreground('make elastic-destroy'), #(1)\n            Command::foreground('make elastic-build'),\n            Command::foreground('make elastic-index'),\n        ),\n    ))\n    -&gt;migrate()\n    -&gt;match(\n        static fn() =&gt; print('Everything has been migrated'),\n        static fn(TimedOut|Failed|Signaled $error) =&gt; printf(\n            'Migrations failed with : %s',\n            $error::class,\n        ),\n    );\n</code></pre> <ol> <li>Since this is a <code>Command</code> you can also specify an input <code>Content</code>, a working directory, and so on...</li> </ol> <p>Then you can add <code>php migrate.php</code> in your deploy process.</p> Tip <p>Here the versions are stored in a database, but you may not have one depending on your project.</p> <p>Instead you can also store them on the filesystem by replacing <code>storeVersionsInDatabase()</code> by <code>storeVersionsOnFilesystem()</code>.</p> <p>Like SQL migrations your migrations name MUST be unique.</p> <p>Here migrations will always be run in the order you specify them in the <code>Sequence</code>.</p>"},{"location":"commands/#running-a-command-once","title":"Running a <code>Command</code> once","text":"<p>If you deploy 2 features that need to rebuild an Elasticsearch index you'll have 2 migrations doing the same thing. When deployed at the same time you'll do the same thing twice. This a waste of time!</p> <p>You might be tempted to remove one of the migrations. But DON'T! Formal has a solution.</p> <p>For this kind of situation you should use <code>Reference</code>s.</p> Script<code>YourCommands</code> migrate.php<pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nuse Formal\\Migrations\\{\n    Factory,\n    Commands\\Migration,\n};\nuse Innmind\\OperatingSystem\\Factory as OS;\nuse Innmind\\Server\\Control\\Server\\{\n    Command,\n    Process\\TimedOut,\n    Process\\Failed,\n    Process\\Signaled,\n};\nuse Innmind\\Url\\Url;\nuse Innmind\\Immutable\\Sequence;\n\nrequire 'path/to/composer/autoload.php';\n\nFactory::of(OS::build())\n    -&gt;storeVersionsInDatabase(\n        Url::of('mysql://user:pwd@127.0.0.1:3306/database'),\n    )\n    -&gt;commands()\n    -&gt;of(Sequence::of(\n        Migration::of(\n            '2024-10-04 Rebuild Elasticsearch for feature A',\n            YourCommands::elasticDestroy,\n            YourCommands::elasticBuild,\n            YourCommands::elasticIndex,\n        ),\n        Migration::of(\n            '2024-10-04 Rebuild Elasticsearch for feature B',\n            YourCommands::elasticDestroy,\n            YourCommands::elasticBuild,\n            YourCommands::elasticIndex,\n        ),\n    ))\n    -&gt;migrate()\n    -&gt;match(\n        static fn() =&gt; print('Everything has been migrated'),\n        static fn(TimedOut|Failed|Signaled $error) =&gt; printf(\n            'Migrations failed with : %s',\n            $error::class,\n        ),\n    );\n</code></pre> <pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nuse Formal\\Migrations\\Commands\\Reference;\nuse Innmind\\Server\\Control\\Server\\Command;\n\nenum YourCommands implements Reference\n{\n    case elasticDestroy;\n    case elasticBuild;\n    case elasticIndex;\n\n    public function commands(): Command\n    {\n        return match ($this) {\n            self::elasticDestroy =&gt; Command::foreground('make elastic-destroy'),\n            self::elasticBuild =&gt; Command::foreground('make elastic-build'),\n            self::elasticIndex =&gt; Command::foreground('make elastic-index'),\n        };\n    }\n}\n</code></pre> <p>If you:</p> <ul> <li>deploy feature A =&gt; the 3 commands are run</li> <li>deploy feature A then deploy feature B =&gt; the 3 commands are run twice</li> <li>deploy feature A and B at the same time =&gt; the 3 commands are run once</li> </ul> Tip <p>Since the <code>Command</code>s are defined in an enum you can't directly inject content (such as an input or a working directory). But you can still do it by calling the <code>migrate</code> method like this:</p> migrate.php<pre><code>use Formal\\Migrations\\Commands\\Reference;\nuse Innmind\\Server\\Control\\Server\\Command;\nuse Innmind\\Filesystem\\File\\Content;\n\n//...\n\n-&gt;migrate(\n    null,\n    static fn(Reference $reference) =&gt; static fn(Command $command) =&gt; match ($reference) {\n        YourCommands::elasticDestroy =&gt; $command-&gt;withInput(Content::ofString('some input')),\n        default =&gt; $command,\n    },\n)\n//...\n</code></pre>"},{"location":"commands/#running-migrations-on-a-remote-server","title":"Running migrations on a remote server","text":"<p>By default the commands are run the same machine the <code>migrate.php</code> script is run.</p> <p>You can also run them on a remote server like this:</p> migrate.php<pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nuse Formal\\Migrations\\{\n    Factory,\n    Commands\\Migration,\n};\nuse Innmind\\OperatingSystem\\{\n    Factory as OS,\n    OperatingSystem,\n};\nuse Innmind\\Server\\Control\\Server\\{\n    Command,\n    Process\\TimedOut,\n    Process\\Failed,\n    Process\\Signaled,\n};\nuse Innmind\\Url\\Url;\nuse Innmind\\Immutable\\Sequence;\n\nrequire 'path/to/composer/autoload.php';\n\nFactory::of(OS::build())\n    -&gt;storeVersionsInDatabase(\n        Url::of('mysql://user:pwd@127.0.0.1:3306/database'),\n    )\n    -&gt;commands()\n    -&gt;of(Sequence::of(\n        Migration::of(\n            '2024-10-04 Rebuild Elasticsearch',\n            Command::foreground('make elastic-destroy'),\n            Command::foreground('make elastic-build'),\n            Command::foreground('make elastic-index'),\n        ),\n    ))\n    -&gt;migrate(\n        static fn(OperatingSystem $os) =&gt; $os\n            -&gt;remote()\n            -&gt;ssh(Url::of('ssh://user@machine-name-or-ip:22/')) #(1)\n            -&gt;processes(),\n    )\n    -&gt;match(\n        static fn() =&gt; print('Everything has been migrated'),\n        static fn(TimedOut|Failed|Signaled $error) =&gt; printf(\n            'Migrations failed with : %s',\n            $error::class,\n        ),\n    );\n</code></pre> <ol> <li>You should ssh keys to automatically log to the remote server.</li> </ol>"},{"location":"philosophy/","title":"Philosophy","text":"<p>Most migration tools allow to define up and down migrations. When something goes wrong while migrating up it then rollbacks to the previous state by applying corresponding down migration.</p> <p>This library purposefully DOES NOT support this mechanism. You can only go up!</p> <p>Allowing to specify down migrations gives you a false sense of security that you can always rollback to a known state.</p> <p>This is most of the time misleading because if your migration failed it means you didn't think of all possible scenarii. At this point your app is in an unknown state. Trying to apply a rollback from this uncertain point will most likely increase the problem.</p> <p>Instead of relying on this false sense of security you should maximize your ability to react quickly to a problem by once again moving forward by writing a new up migration once the unknown state is understood.</p> <p>You can achieve this via quality assurances:</p> <ul> <li>use Pull Requests and review them</li> <li>write automated tests and run them in a CI</li> <li>automate the whole deploy process of your app</li> </ul> <p>In the case you really want to write down migrations you can still build such system on top of this library. But you'd probably be better off looking for another tool.</p>"},{"location":"sql/","title":"SQL","text":""},{"location":"sql/#write-your-migrations-in-files","title":"Write your migrations in files","text":"<p>The simplest way to write migrations is in plain SQL files.</p> <p>With this strategy all your files must be in the same folder and will be sorted alphabetically for a guarantee of execution order.</p> <p>You can use any naming strategy but here's a good starting point:</p> <pre><code>migrations/\n    2024_10_03_some_feature.sql\n    2024_10_03_concurrent_feature.sql\n    2024_10_11_another_one.sql\n</code></pre> Tip <p>These migrations whould be executed in this order:</p> <ul> <li><code>2024_10_03_concurrent_feature.sql</code></li> <li><code>2024_10_03_some_feature.sql</code></li> <li><code>2024_10_11_another_one.sql</code></li> </ul> <p>Each query inside a file must be separated by a line starting with <code>--</code> (1). A query can be written on multiple lines.</p> <ol> <li>Which the SQL symbol for comments. This allows to write comments in your file.</li> </ol> <p>You can then run them via a script like this one:</p> migrate.php<pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nuse Formal\\Migrations\\Factory;\nuse Innmind\\OperatingSystem\\Factory as OS;\nuse Innmind\\Url\\Url;\n\nrequire 'path/to/composer/autoload.php';\n\n$dsn = Url::of('mysql://user:pwd@127.0.0.1:3306/database');\n\nFactory::of(OS::build())\n    -&gt;storeVersionsInDatabase($dsn)\n    -&gt;sql()\n    -&gt;files(Path::of('path/to/migrations/'))\n    -&gt;migrate($dsn)\n    -&gt;match(\n        static fn() =&gt; print('Everything has been migrated'),\n        static fn(\\Throwable $error) =&gt; printf(\n            'Migrations failed with the message : %s',\n            $error-&gt;getMessage(),\n        ),\n    );\n</code></pre> <p>The <code>$dsn</code> can be any value supported by <code>formal/access-layer</code>.</p> <p>Then you can add <code>php migrate.php</code> in your deploy process.</p> Info <p>Here the versions are stored in the database being migrated, but you use different databases if you want.</p> <p>Alternatively you can store versions on the filesystem by using <code>storeVersionsOnFilesystem()</code> instead of <code>storeVersionsInDatabase()</code>.</p>"},{"location":"sql/#write-your-migrations-in-php","title":"Write your migrations in PHP","text":"migrate.php<pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nuse Formal\\Migrations\\{\n    Factory,\n    SQL\\Migration,\n};\nuse Formal\\AccessLayer\\Query;\nuse Innmind\\OperatingSystem\\Factory as OS;\nuse Innmind\\Url\\Url;\nuse Innmind\\Immutable\\Sequence;\n\nrequire 'path/to/composer/autoload.php';\n\n$dsn = Url::of('mysql://user:pwd@127.0.0.1:3306/database');\n\nFactory::of(OS::build())\n    -&gt;storeVersionsInDatabase($dsn)\n    -&gt;sql()\n    -&gt;of(Sequence::of(\n        Migration::of(\n            'some feature',\n            Query\\SQL::of('CREATE TABLE `some_feature` (`value` INT NOT NULL);'),\n        ),\n        Migration::of(\n            'another feature',\n            Query\\SQL::of('CREATE TABLE `another_feature` (`value` INT NOT NULL);'),\n        ),\n    ))\n    -&gt;migrate($dsn)\n    -&gt;match(\n        static fn() =&gt; print('Everything has been migrated'),\n        static fn(\\Throwable $error) =&gt; printf(\n            'Migrations failed with the message : %s',\n            $error-&gt;getMessage(),\n        ),\n    );\n</code></pre> <p>Then you can add <code>php migrate.php</code> in your deploy process.</p> <p>Here the migrations are always run in the order you specify. Even though the migration name <code>another feature</code> comes first alphabetically it still executed last. This is intended so you don't need to think too much about the execution order when specifying these names.</p> <p>Your migrations name still MUST be unique. Otherwise some won't be run.</p> <p>In the example above there's only one <code>Query\\SQL</code> query per migration but you can add multiple ones. And they can be any instance of the <code>Formal\\AccessLayer\\Query</code> interface.</p> Tip <p>The above example defines the migrations in the same file as the script. This will quickly become a large file. Instead you should split your migrations by features like this:</p> Script<code>FeatureA</code><code>FeatureB</code><code>Etc</code> migrate.php<pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nuse Formal\\Migrations\\{\n    Factory,\n    SQL\\Migration,\n};\nuse Formal\\AccessLayer\\Query;\nuse Innmind\\OperatingSystem\\Factory as OS;\nuse Innmind\\Url\\Url;\nuse Innmind\\Immutable\\Sequence;\n\nrequire 'path/to/composer/autoload.php';\n\n$dsn = Url::of('mysql://user:pwd@127.0.0.1:3306/database');\n\nFactory::of(OS::build())\n    -&gt;storeVersionsInDatabase($dsn)\n    -&gt;sql()\n    -&gt;of(\n        FeatureA\\Migrations::load()\n            -&gt;append(FeatureB\\Migrations::load())\n            -&gt;append(Etc\\Migrations::load()),\n    )\n    -&gt;migrate($dsn)\n    -&gt;match(\n        static fn() =&gt; print('Everything has been migrated'),\n        static fn(\\Throwable $error) =&gt; printf(\n            'Migrations failed with the message : %s',\n            $error-&gt;getMessage(),\n        ),\n    );\n</code></pre> <pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nnamespace FeatureA;\n\nuse Formal\\Migrations\\SQL\\Migration;\nuse Innmind\\Immutable\\Sequence;\n\nfinal class Migrations\n{\n    /** @return Sequence&lt;Migration&gt; */\n    public static function load(): Sequence\n    {\n        return Sequence::of(\n            Migration::of(\n                'init feature A',\n                SQL::of('CREATE TABLE `featureA` (`value` INT NOT NULL)'),\n            ),\n            // etc...\n        );\n    }\n}\n</code></pre> <pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nnamespace FeatureB;\n\nuse Formal\\Migrations\\SQL\\Migration;\nuse Innmind\\Immutable\\Sequence;\n\nfinal class Migrations\n{\n    /** @return Sequence&lt;Migration&gt; */\n    public static function load(): Sequence\n    {\n        return Sequence::of(\n            Migration::of(\n                'init feature B',\n                SQL::of('CREATE TABLE `featureB` (`value` INT NOT NULL)'),\n            ),\n            // etc...\n        );\n    }\n}\n</code></pre> <pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nnamespace Etc;\n\nuse Formal\\Migrations\\SQL\\Migration;\nuse Innmind\\Immutable\\Sequence;\n\nfinal class Migrations\n{\n    /** @return Sequence&lt;Migration&gt; */\n    public static function load(): Sequence\n    {\n        return Sequence::of(\n            Migration::of(\n                'init etc',\n                SQL::of('CREATE TABLE `etc` (`value` INT NOT NULL)'),\n            ),\n            // etc...\n        );\n    }\n}\n</code></pre> <p>As long as each feature doesn't depend on each other it doesn't matter that the whole <code>Sequence</code> is not sorted. And even if they depend on each other you can sort them in <code>migrate.php</code> by calling <code>Sequence-&gt;sort()</code>.</p>"},{"location":"sql/#transactions","title":"Transactions","text":"<p>Formal doesn't apply transactions on migrations. Because databases like MySQL automatically will automatically commit a transaction when you modify a table schema.</p> <p>Instead of Formal trying to understand the state of the connection when your migrations are applied it lets you handle the transactions:</p> <ul> <li>If your migration only change a schema then don't do anything (1).</li> <li>Otherwise start your migration with <code>START TRANSACTION;</code> and end it with <code>COMMIT;</code> (2).</li> </ul> <ol> <li>Granted your database doesn't support it. If it does you should use it.</li> <li>These are native SQL queries.</li> </ol>"}]}